---
title: 多线程基础
tags:
  - 多线程
  - java
categories:
  - 学习
description: "\U0001F389 Java 基础之多线程"
abbrlink: 53471b9a
date: 2023-02-17 10:27:18
cover:
---
## 多线程的实现

​	多线程的实现在 java 中有**两**种

- <span style="font-size: 30px">继承 Thread</span>，但是这种方式有局限性，就是 java 的 **单继承局限问题**
- <span style="font-size: 30px">实现 Runnable 接口</span>。使用接口定义的线程类会更加**合理**。

### 继承 Thread 类

​		任何类只需要继承 Thread 类就可以成为一个线程的**主类**。但是既然是主类就必须有它的使用方法，而线程启动的主方法需要重写 Thread 类中的 **run()** 方法实现。

```java
public class ThreadExtendTest extends Thread {
    private String name;

    public ThreadExtendTest() {}
    public ThreadExtendTest(String name) {
        this.name = name;
    }

    /**
     * 重写 run 方法，作为线程的主操作方法
     */
    @Override
    public void run() {
        for (int i = 0; i < 200; i++) {
            System.out.println(this.name + "--->" + i);
        }
    }
}
```

​		所有线程与进程是一样的，都必须轮流去抢占资源，所以多线程的执行应该是**多个线程彼此交替执行**。也就是说，如果直接调用 run() 方法，并不能启动多线程，<span style="color: red;font-size: 20px;background-color: #ff4;">**多线程启动的唯一方法就是 Thread 类中的 start() 方法：public void start() （调用此方法执行的方法体是 run() 方法定义的代码）**</span>

```java
class TestDemo {
    public static void main(String[] args) {
        // 实例化多线程类对象
        ThreadExtendTest t1 = new ThreadExtendTest("线程A");
        ThreadExtendTest t2 = new ThreadExtendTest("线程B");
        ThreadExtendTest t3 = new ThreadExtendTest("线程C");
        // 启动多线程
        t1.start();
        t2.start();
        t3.start();
    }
}
```

​		上面的程序首先实例化了 3 个线程类对象，然后调用了通过 **Thread 类继承**而来的 start() 方法，进行多线程的启动。通过上面程序可以发现所有的线程都是**交替运行**的。

### 实现 Runnable 接口

​		使用 Thread 类的确可以方便的进行多线程的实现，但是这种方式的**最大的缺点就是单继承的问题**。为此，在 Java 中也**可以利用 Runnable 接口来实现多线程**，而这个接口的定义如下：可以看出来是**函数式接口**，可以用 lambda 表达。

```java
@FunctionalInterface
public interface Runnable {
	public void run()
}
```

​		在 Runnable 接口中也定义了 run() 方法，所以线程的主类只需要**重写此方法**即可。

```java
public class InterfaceThreadTest implements Runnable{
    private String name;

    public InterfaceThreadTest() {
    }

    public InterfaceThreadTest(String name) {
        this.name = name;
    }

    // 重写 run 方法
    @Override
    public void run() {
        for (int i = 0; i < 200; i++) {
            System.out.println(this.name + "--->" + i);
        }
    }
}
```

​		以上程序实现了 Runnable 接口并且正常重写了 run() 方法，但是却会存在一个新的问题：要启动多线程，一定需要通过 Thread 类中的 start() 方法才可以完成。如果继承了 Thread 类，那么可以直接将 Thread 父类中的 start() 方法继承下来继续使用，而 **Runnbale 接口并没有提供可以被继承的 start() 方法**，这时候应该如何启动多线程呢？此时可以观察 <span style="font-size: 20px; color: red; background-color: #ff4">**Thread 类中提供的一个有参构造方法：public Thread(Runnable target)**</span>，本方法可以接收一个 Runnbale 接口对象。 

```java
class InterfaceThreadTestDemo {
    public static void main(String[] args) {
        // 实例化线程对象
        InterfaceThreadTest t1 = new InterfaceThreadTest("线程A");
        InterfaceThreadTest t2 = new InterfaceThreadTest("线程B");
        InterfaceThreadTest t3 = new InterfaceThreadTest("线程C");
        // 利用 Thread 类中的构造方法启动多线程
        // 启动方法 start() 莫忘
        new Thread(t1).start();
        new Thread(t2).start();
        new Thread(t3).start();
    }
}
```

​		本程序首先利用 Thread 类的对象包装了 Runnable 接口对象实例（new Thread(t1).start()），然后利用 Thread 类的 start() 方法就可以实现多线程的启动。

> 在上面 Runnable 接口代码处提到过，该接口使用了**函数式接口**，所以也可以用 **Lambda 表达式编写代码。**
>
> ```java
> class LamdaRunnableDemo {
>  public static void main(String[] args) {
>      // Lambda 风格编写线程A
>      new Thread(() -> {
>          for (int i = 0; i < 200; i++) {
>              System.out.println("线程A--->" + i);
>          }
>      }).start();
> 
>      // Lambda 风格编写线程B
>      new Thread(() -> {
>          for (int i = 0; i < 200; i++) {
>              System.out.println("线程B--->" + i);
>          }
>      }).start();
>  }
> }
> ```

​		**使用 Runnable 接口可以有效避免单继承局限问题，所以在实际的开发中，对于多线程的实现<span style="color:red">首先选择的就是 Runnable 接口</span>。**

### 多线程两种实现方式的区别

- 实现 Runnable 接口 可以**避免单继承的局限**

- Thread 类也是 Runnable 接口的子类

  ```java
  public class Thread implements Runnable
  ```

- 使用 Runnable 接口可以更加方便的表示出**数据共享**的概念

  1. 通过继承 Thread 类实现卖票程序

     ```java
     public class SellTicketExtend extends Thread {
         // 5张票
         private int ticket = 5;
     
         // 定义线程主方法
         @Override
         public void run() {
             for (int i = 0; i < 50; i++) {
                 if (ticket > 0) {
                     System.out.println("卖票,ticket = " + this.ticket--);
                 }
             }
         }
     }
     
     class SellTicketExtendTest {
         public static void main(String[] args) {
             // 创建线程对象
             SellTicketExtend s1 = new SellTicketExtend();
             SellTicketExtend s2 = new SellTicketExtend();
             SellTicketExtend s3 = new SellTicketExtend();
             // 启动线程
             s1.start();
             s2.start();
             s3.start();
         }
     }
     ```

     ​		本程序定义了 3 个线程对象，希望 3 个线程对象同时卖 5 张车票。而最终的结果是一共卖出了 15 张票，等于每一个线程各自卖各自的 5 张票。

  2. 利用 Runnable 接口实现多线程

     ```java
     public class SellTicketRunnable implements Runnable {
         private int ticket = 5; // 定义 5 张票
     
         @Override
         public void run() {
             for (int i = 0; i < 50; i++) {
                 if (ticket > 0) {
                     System.out.println("卖票，ticket = " + this.ticket--);
                 }
             }
         }
     }
     
     class SellTicketRunnableTest {
         public static void main(String[] args) {
             // 实例化线程对象
             SellTicketRunnable runnable = new SellTicketRunnable();
             new Thread(runnable).start();
             new Thread(runnable).start();
             new Thread(runnable).start();
         }
     }
     
     /**
         卖票，ticket = 5
         卖票，ticket = 3
         卖票，ticket = 2
         卖票，ticket = 4
         卖票，ticket = 1
     */
     ```

     ​		本程序使用 Runnable 接口实现了多线程，同时启动了 3 个线程对象，但是与继承 Thread 操作的卖票例子不同，这 3 个线程对象都占着同一个 Runnable 接口对象的引用，所以实现了**数据共享**的操作。

     > 需要注意的是，继承 Thread 类的操作也可以实现数据共享的概念，但是这种实现方式往往不被采用，原因是**：如果想要启动多线程肯定要依靠 Thread 类的 start() 方法，但是依靠 Runnable 接口实现的线程主题类没有 start() 方法的定义，而继承了 Thread 实现的线程主体类存在 start() 方法的定义，如果通过 Thread 类继承的多线程主体类，再利用 Thread 类去实现多线程，这样明显不合适。**

<h3>总结：多线程的两种实现方式及区别</h3>

- 多线程的两种实现方式都需要一共线程的主类，而这个类可以实现 Runnable 接口或继承 Thread 类，**不管使用何种方式都必须在子类中重写 run() 方法**，此方法为线程的主方法；
- Thread 类是 Runnable 接口的子类，并且使用 Runnable 接口可以**避免单继承局限**，并且可以更加方便的实现**数据共享**的概念。

## 线程的操作状态

​		要想实现多线程，必须在主线程中创建新的线程对象。任何线程一般都具有 5 种状态，即<span style="color: red;font-size: 20px; background-color: #ff4">**创建、就绪、运行、堵塞和终止**</span>

![image-20230216175035768](https://img-blog.csdnimg.cn/img_convert/01454c0a655ce2b89ab156ef185daf0c.png)

1. **创建状态**

   在程序中用**构造方法创建一个线程对象**后，新的线程对象便处于**新建状态**，此时，它**已经有相应的内存空间和其他资源**，但还处于不可运行状态。新建一个线程对象可采用 Thread 类构造方法来实现，例如：Thread t = new Thread().

2. **就绪状态**

   新建线程对象后，**调用该线程的 <span style="color:red">start() 方法</span>**就可以启动线程。当线程启动时，线程就进入了**就绪状态**。此时，线程将进入线程队列排队，等待 CPU 服务，这表明它**已经具备了运行条件**。

3. **运行状态**

   当**就绪状态的线程被调用**并获得处理器资源时，线程就进入了**运行状态**，此时，自动调用该线程对象的 **<span style="color:red">run() 方法</span>**。run() 方法定义了该线程的**操作和功能**。

4. **堵塞状态**

   一个**<span style="color:red">正在执行的线程</span>**在某些特殊情况下，如人为挂起或需要执行耗时的输入输出操作时，将让出 CPU 并暂时中止自己的执行，进入**堵塞状态**。在可执行状态下，如果调用 **sleep()、suspend()、wait()**等方法，线程都将进入阻塞状态。堵塞时候，线程**不能进入排队队列**，只有当引起堵塞的原因被消除后，线程才可以转入**<span style="color:red">就绪状态</span>**。

5. **终止状态**

   线程调用 **stop() 方法或 run() 方法执行结束**后，就处于**终止状态**。处于终止状态的线程**不再具有继续运行**的能力。

## 多线程常用操作方法

### 线程命名和获取

|                    方法                     | 类型 | 描述                                                        |
| :-----------------------------------------: | :--: | :---------------------------------------------------------- |
| public Thread(Runnable target, String name) | 构造 | 实例化线程对象，接收 Runnable接口子类对象，同时设置线程名称 |
|   public final void setName(String name)    | 普通 | 设置线程名字                                                |
|        public final String getName()        | 普通 | 获取线程名字                                                |

​		由于**多线程的状态不确定**，所以线程的**名字**就成为了**唯一的分辨标记**，则在定义线程名称时一定要在**线程<span style="color:red">启动前</span>设置名字**，而尽量不要崇明，且**尽量不要为已经启动的线程修改名字**。

​		由于**线程的状态不确定**，所以每次可以操作的都是**正在执行 run() 方法的线程**，那么**取得当前线程对象**的方法为：public static Thread <span style="color:red">**currentThread**()</span>。

```java
public class GetNameThread implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}

class GetNameThreadTest {
    public static void main(String[] args) {
        GetNameThread thread = new GetNameThread();
        new Thread(thread, "自己的线程A").start();
        new Thread(thread).start();
        new Thread(thread, "自己的线程B").start();
        new Thread(thread).start();
        new Thread(thread).start();
    }
}
/**
    自己的线程A
    Thread-0
    Thread-2
    自己的线程B
    Thread-1
*/
```

​		通过本程序可以发现，当**实例化 Thread 类对象**时可以**自己定义线程名称**，也**可以采用默认名称**进行操作。在 **<span style="color:red;">run() 方法中可以使用 currentThread() 取得当前线程对象</span>**后再取得具体的线程名字。

### 线程的休眠

​		线程的休眠指的是让程序的执行速度变慢一些，在 Thread 类中线程**休眠操作**方法为： **sleep(long millis) ,单位：毫秒（ms）**。

```java
public class SleepThread implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 10000; i++) {
            try {
                // 每次执行休息一秒
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + ", i = " + i);
        }
    }
}

class SleepThreadTest {
    public static void main(String[] args) {
        SleepThread sleepThread = new SleepThread();
        new Thread(sleepThread,"线程A").start();
    }
}
```

​		本程序在每一次线程执行 run() 方法时候都会产生 1s 左右的延迟后才会进行内容的输出，所以整体代码执行速度有所降低。

​		**建议设置多个线程试试**

### 线程的优先级

​		在java的线程操作中，所有的线程在运行前都会保持就绪状态，此时哪个线程的**优先级高**，哪个线程就有可能会**先被执行**。

​		如果想要进行线程优先级的设置，在thread类中提供了支持的**方法及常量**。

| 方法或常量                                    | 类型 | 描述                 |
| :-------------------------------------------- | :--: | -------------------- |
| public static final int MAX_PRIORITY          | 常量 | 最高优先级，数值为10 |
| public static final int NORM_PRIORITY         | 常量 | 中等优先级，数值为5  |
| public static final int MIN_PRIORITY          | 常量 | 最低优先级，数值为1  |
| public final vod setPriority(int newPriority) | 普通 | 设置线程优先级       |
| public final int getPriority()                | 普通 | 获取线程优先级       |

```java
public class PriorityThead implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + ", i = " + i);
        }
    }
}

class PriorityThreadTest {
    public static void main(String[] args) {
        // 实例化线程对象
        PriorityThead priorityThead = new PriorityThead();
        Thread t1 = new Thread(priorityThead, "线程A");
        Thread t2 = new Thread(priorityThead, "线程B");
        Thread t3 = new Thread(priorityThead, "线程C");

        // 设置线程优先级
        t3.setPriority(Thread.MAX_PRIORITY);

        // 查看线程优先级
        System.out.println(t3.getName() + "优先级：" + t3.getPriority());
        System.out.println(t2.getName() + "优先级：" + t2.getPriority());
        System.out.println(t1.getName() + "优先级：" + t1.getPriority());

        // 开启线程
        t1.start();
        t2.start();
        t3.start();
    }
}
```

​		本程序定义了3个线程对象，并在线程对象**启动前**，利用setPriority()方法修改了一个线程的优先级。

## 线程的同步与死锁

​		程序利用线程可以进行更为高效的程序处理，如果在没有多线程的程序中，一个程序在处理某某些资源时候会有主方法（主线程全部进行处理），但是这样的处理速度一定会比较慢。如果采用了多线程的处理机制，利用主线程创建出许多子线程（相当于多了许多帮手），一起进行资源的操作，那么执行效率一定会比只有一个主线程更高。

​		在程序开发中，所有程序都是通过主方法执行的，而主方法本身就属于一个主线程，所以通过主方法拆关键的新的线程对象都是子线程。利用子线程可以进行**<span style="color:red">异步</span>**的操作处理，这样可以在不影响主线程运行的前提下进行其他操作，程序的执行速度不仅变快了，并且操作起来也不会产生太多的延迟。

​		虽然使用多线程同时处理资源效率比单线程高许多，但是多个线程如果操作同一个资源一定会存在一些问题，如资源操作的完整性问题。

### 同步问题的引出

​		同步是多线程开发中的一个重要概念，既然有同步，就一定会存在不同步的操作。

​		<span style="color:red">**多个线程操作同一资源就有可能出现不同步的问题**</span>，例如：现在产生N个线程对象实现卖票操作，同时为了更加明显的观察不同步所带来的问题，所以本程序将使用线程的休眠操作。

```java
public class SynchronousThread implements Runnable {
    private int ticket = 5; // 一共有5张票
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            // 判断当前是否还有剩余的票
            if (this.ticket > 0) {
                try {
                    Thread.sleep(1000); // 休眠 1s，模拟延迟
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() +
                        " 卖票，ticket = " + this.ticket--);
            }
        }
    }
}

class SynchronousThreadTest {
    public static void main(String[] args) {
        SynchronousThread thread = new SynchronousThread();
        new Thread(thread, "票贩子A").start();
        new Thread(thread, "票贩子B").start();
        new Thread(thread, "票贩子C").start();
        new Thread(thread, "票贩子D").start();
    }
}

/**
    票贩子D 卖票，ticket = 4
    票贩子A 卖票，ticket = 5
    票贩子B 卖票，ticket = 3
    票贩子C 卖票，ticket = 2
    票贩子A 卖票，ticket = 0
    票贩子D 卖票，ticket = -1	错误的数据，因为不同步
    票贩子C 卖票，ticket = -2 错误的数据
    票贩子B 卖票，ticket = 1
*/
```

​		本程序模拟了一共卖票程序的实现，其中将有4个线程对象共同完成卖票的任务，为了保证每次有甚于票数时实现卖票操作，在卖票前添加了一个判断的条件（if（this.ticket > 0）），满足此条件的线程对象才可以卖票，不过根据最终的结果却发现，这个判断条件的作用并不明显。

### 同步操作

​		为了解决线程不同步的问题，就必须使用同步操作。所谓同步操作就是一个代码块中的多个操作在同一个时间段内只能有一个线程进行，其他线程要等待此线程完成后才可以继续执行，即**上锁**。

![image-20230216214010847](https://img-blog.csdnimg.cn/img_convert/9645007556b81ae90c7fb7c20aab92ca.png)

​		在java里面如果想要实现线程的同步，操作可以使用  <span style="color:red;font-size:20px">**synchronized**</span> 关键字。synchronized 关键字可以通过以下两种方式进行使用。

- 同步代码块：利用 synchronized 包装的代码块，但是需要**指定同步对象**，一般设置为 **this**；

  ```java
  public class SynchronizedThread implements Runnable{
  
      private int ticket = 5;
  
      @Override
      public void run() {
          for (int i = 0; i < 20; i++) {
              // 定义同步代码块
              synchronized (this) {
                  // 判断是否还有剩余票
                  if (this.ticket > 0) {
                      try {
                          // 休眠 1s，模拟延迟
                          Thread.sleep(100);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      System.out.println(Thread.currentThread().getName() +
                              " 卖票，ticket = " + this.ticket--);
                  }
              }
          }
      }
  }
  
  class SynchronizedThreadTest {
      public static void main(String[] args) {
          SynchronizedThread thread = new SynchronizedThread();
          new Thread(thread, "线程A").start();
          new Thread(thread, "线程B").start();
          new Thread(thread, "线程C").start();
          new Thread(thread, "线程D").start();
      }
  }
  
  /**
      线程D 卖票，ticket = 5
      线程B 卖票，ticket = 4
      线程B 卖票，ticket = 3
      线程A 卖票，ticket = 2
      线程A 卖票，ticket = 1
  */
  ```

  ​		本程序将判断是否有票以及卖票的两个操作都统一放到了同步代码块中，这样当某一个线程操作时，其他线程无法进入到方法中进行操作，从而实现了线程的同步操作。

- 同步方法：利用 synchronized 定义的方法。

```java
public class SynchronizedMethodThread implements Runnable{
    private int ticket = 5;
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            this.sale(); // 卖票操作
        }
    }

    // synchronized 定义方法
    public synchronized void sale() {
        if (this.ticket > 0) {
            try {
                // 休眠，模拟延迟
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() +
                    " 卖票，ticket = " + this.ticket--);
        }
    }
}

class SynchronizedMethodThreadTest {
    public static void main(String[] args) {
        SynchronizedMethodThread thread = new SynchronizedMethodThread();
        new Thread(thread, "线程A").start();
        new Thread(thread, "线程B").start();
        new Thread(thread, "线程C").start();
        new Thread(thread, "线程D").start();
    }
}

/**
    线程A 卖票，ticket = 5
    线程A 卖票，ticket = 4
    线程B 卖票，ticket = 3
    线程B 卖票，ticket = 2
    线程D 卖票，ticket = 1
*/
```

​		此时利用同步方法同样解决了同步操作的问题。但是在此处需要说明一个问题：**加入同步后明显比不加入同步慢许多**，所以**同步代码性能会很低**，但是数据的安全性会高，或者可以成为**线程安全性高**。

> **同步和异步有什么区别，在什么情况下分别使用它们？举例说明**
>
> ​		如果**一块**数据要在**多个线程间进行共享**。例如：正在写的数据以后可能被另一个线程读到，或者正好在读的数据可能已经被另一个线程写过了，那么这些数据就是**<span style="color:red">共享数据</span>**，必须**<span style="color:red">进行同步存取</span>**。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且**不希望让程序等待方法的返回**时，就应该使用**异步编程**，在很多情况下采用异步途径往往更有效率。



> **abstract 的 method 是否可以同时是 static，是否可以同时是 native，是否可以同时是 synchronized？**
>
> ​		method、static、native、synchronized 都**<span style="color:red">不能和 “abstract” 同时声明</span>**方法



> **当一个线程进入一个对象的 synchronized 方法后，其他线程是否可以访问此对象的其他方法？**
>
> ​		**不能访问**，一个对象操作一个 synchronized 方法**<span style="color:red">只能由一个线程访问</span>**。

### 死锁

​		同步就是指**<span style="color:red;font-size:20px">一个线程要等待另外一个线程执行完毕才会继续执行</span>**的一个操作形式，虽然在一个程序中，使用同步可以保证资源共享操作的正确性，但是过多同步也会产生问题。**多个线程抢占一个资源，导致线程死锁**。

​		死锁就是指两个线程都在等待**彼此先完成**，造成程序的停滞状态，一般程序的死锁都是在**程序运行**时出现。

> **请解释多个线程访问同一资源时需要考虑到那些情况？有可能带来哪些问题？**
>
> - 多个线程访问同一资源时，考虑到数据操作的安全性问题，**一定要使用同步操作**。同步操作由以下两种操作模式：
>
>   ```java
>   // 同步代码块
>   synchronized(锁定对象) {代码}
>   
>   // 同步方法
>   public synchronized 返回值 方法名称() {代码}
>   ```
>
> - **过多的同步操作**有可能会带来**死锁**问题，导致程序进入**停滞状态**。

## 生产者与消费者案例

​		在开发中线程的运行状态并不固定，所以**只能利用线程的名字**以及**当前执行的线程对象**来进行区分。但是**多个线程间**也有可能会出现**数据交互**的情况。

### 问题引出

​		在生产者和消费者模型中，生产者不断生产，消费者不断取走生产者生产的产品。

![image-20230216223648707](https://img-blog.csdnimg.cn/img_convert/58b9cc98a5ad43ef1a4c5eeb9f881e71.png)

​		从上图中可以看出，生产者生产出信息后将其放到一个区域中，然后消费这从此区域中取出数据，但是在本程序中因为牵涉线程运行的**不确定性**，所以会存在以下两个问题。

1. 假设生产者线程向数据存储空间添加信息的名称，还没有加入该信息的内容，程序就切换到了消费者线程，消费者线程将把该信息的名称和上一个信息的内容联系到一起。
2. 生产者放了若干次的数据，消费者才开始取数据，或者是消费者取完一个数据后，还没等到生产者放入新的数据，又重复取出已取过的数据。

```java
// Message.java
public class Message {
    private String title;       // 保存信息的标题
    private String content;     // 保存信息的内容

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }
}
```

```java
// Producer.java
public class Producer implements Runnable{      // 定义生产者
    private Message msg = null;

    public Producer(Message msg) {
        this.msg = msg;
    }

    @Override
    public void run() {
        // 生产 50 次数据
        for (int i = 0; i < 50; i++) {
            if (i % 2 == 0) {
                // 设置 title 属性
                this.msg.setTitle("张三");
                try {
                    // 延迟操作
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 设置 content 属性
                this.msg.setContent("你好，张三");
            } else {
                // 设置 title 属性
                this.msg.setTitle("zhangsan");
                try {
                    // 延迟操作
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 设置 content 属性
                this.msg.setContent("hello,zhangsan");
            }
        }
    }
}
```

```java
// Consumer.java
public class Consumer implements Runnable {         // 设置消费者
    private Message msg = null;

    public Consumer(Message msg) {
        this.msg = msg;
    }

    @Override
    public void run() {
        // 取走 50 次数据
        for (int i = 0; i < 50; i++) {
            try {
                // 延迟操作
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(this.msg.getTitle() + "--->" + this.msg.getContent());
        }
    }
}
```

```java
// Test测试类
public class TestDemo {
    public static void main(String[] args) {
        // 定义 message 对象，用于保存和取出数据
        Message msg = new Message();
        // 启动生产者线程
        new Thread(new Producer(msg)).start();
        // 启动消费者线程
        new Thread(new Consumer(msg)).start();
    }
}

/**
    张三--->你好，张三
    张三--->hello,zhangsan
    张三--->你好，张三
    zhangsan--->你好，张三
    zhangsan--->hello,zhangsan
    ...
*/
```

​		通过本程序的运行结果可以发现两个严重的问题：设置数据错位：数据会重复取出和重复设置。

### 解决数据错乱问题

​		数据错位完全是因为**<span style="color:red">非同步</span>**的操作，所以应该使用**同步处理**。因为取出和设置是**两个不同的操作**，所以要想进行同步控制，就需要将其**定义在一个类里面**完成。

```java
// 解决数据错乱问题。
// Message.java
public class Message {
    private String title;       // 保存信息的标题
    private String content;     // 保存信息的内容

    public synchronized void set(String title, String content) {
        this.title = title;
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.content = content;
    }

    public synchronized void get(){
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(this.title + "-->" + this.content);
    }
    
    // getter、setter 省略
}

```

​		生产者和消费者同理需要修改

```java
// Producer.java
public class Producer implements Runnable{      // 定义生产者
    private Message msg = null;

    public Producer(Message msg) {
        this.msg = msg;
    }

    @Override
    public void run() {
        // 生产 50 次数据
        for (int i = 0; i < 50; i++) {
            if (i % 2 == 0) {
                this.msg.set("张三", "你好，张三");
            } else {
                this.msg.set("zhangsan", "hello,zhangsan");
            }
        }
    }
}
```

```java
// Consumer.java
public class Consumer implements Runnable {         // 设置消费者
    private Message msg = null;

    public Consumer(Message msg) {
        this.msg = msg;
    }

    @Override
    public void run() {
        // 取走 50 次数据
        for (int i = 0; i < 50; i++) {
            this.msg.get();
        }
    }
}
```

​		启动测试类

```
    张三-->你好，张三
    zhangsan-->hello,zhangsan
    zhangsan-->hello,zhangsan
    张三-->你好，张三
    张三-->你好，张三
    ...
```

​		本程序利用同步方法解决了数据的错位问题，但是同时也可以发现，重复取出与重复设置的问题更加严重了。

### 解决数据重复问题

​		要想解决数据洪福的问题，需要**<span style="color:red">等待及唤醒</span>**机制，而这一机制的实现只能依靠Object类完成，在Object类中定义了 3 个方法完成线程的操作。

|                         方法                         | 类型 |        描述        |
| :--------------------------------------------------: | :--: | :----------------: |
| public final void wait() throws InterruptedException | 普通 |     线程的等待     |
|              public final void notify()              | 普通 | 唤醒第一个等待线程 |
|            public final void notifyAll()             | 普通 |  唤醒全部等待线程  |

​		一个线程可以为其设置**等待状态**，但是对于唤醒的操作却有两个：**<span style="color:red;font-size:20px">notify()、notifyAll()</span>**。一般来说，所有等待的线程会按照**顺序**进行排列。如果使用了 **notify() 方法**，则会**<span style="color:red;font-size:20px">唤醒第一个等待的线程</span>**执行；如果使用了 **notifyAll()** 方法，则会**<span style="color:red;font-size:20px">唤醒所有的等待线程</span>**。哪个线程的**<span style="color:red;font-size:20px">优先级高</span>**，哪个线程就**<span style="color:red;font-size:20px">有可能</span>**先执行。

​		如果想让生产者不重复生产，消费者不重复取走，则可以增加一个标志位，假设标志位为 Boolean 类型变量。如果标志位的内容为 true ，则表示**可以生产**，但是**不能取走**，如果此时线程执行到了，消费者线程则**应该等待**；如果标志位的内容为 false，则表示**可以取走**，但是**不能生产**，如果生产者线程运行，则**应该等待。**

​		要想完成解决数据重复的功能，直接修改 Message 类即可。在 Message 类中加入标志位，并通过判断标志位完成**等待与唤醒**的操作。

```java
// Message.java
public class Message {
    private String title;       // 保存信息的标题
    private String content;     // 保存信息的内容
    // 增加标志位
    // flag == true  : 表示可以生产，但是不可以取走
    // flag == false : 表示可以取走，但是不可以生产
    private boolean flag = true;

    public synchronized void set(String title, String content) {
        // 已经生产过了，不能继续生产
        if (this.flag == false) {
            try {
                // 让线程进入等待状态
                super.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // 如果允许生产，继续执行
        this.title = title;
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.content = content;
        this.flag = false;          // 生产已经完成，修改标志位
        super.notify();             // 唤醒等待线程
    }

    public synchronized void get(){
        // 如果未生产，不允许取走
        if (this.flag == true) {
            try {
                // 线程等待
                super.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(this.title + "-->" + this.content);
        this.flag = true;   // 已经取走，可以生产
        super.notify();     // 唤醒等待线程
    }
}
```

## 线程的终止

​		通过设置标志位的方式停止一个线程的运行

```java
public class StopThread implements Runnable{
    private boolean flag = true;
    @Override
    public void run() {
        int i = 0;
        // 第一层控制是否停止
        while (this.flag) {
            // 循环输出
            while (true) {
                System.out.println(Thread.currentThread().getName() + "运行，i = " + (i++));
            }
        }
    }

    /**
     * 停止方法
     */
    public void stop() {
        // 将标志位设置为 false
        this.flag = false;
    }
}

class StopThreadTest {
    public static void main(String[] args) throws InterruptedException {
        StopThread thread = new StopThread();
        Thread t = new Thread(thread, "线程A");
        t.start();
        thread.stop();
    }
}
```

